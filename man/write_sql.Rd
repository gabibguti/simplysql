% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write_sql.R
\name{write_sql}
\alias{write_sql}
\title{Create a safe SQL expression via parametric string interpolation}
\usage{
write_sql(.sql, ..., .envir = parent.frame(), .con = NULL)
}
\arguments{
\item{.sql}{string containing the parametric SQL expression.}

\item{...}{
  Arguments passed on to \code{\link[glue:glue_sql]{glue::glue_data_sql}}, \code{\link[glue:glue]{glue::glue_data}}
  \describe{
    \item{\code{.na}}{[\code{character(1)}: \code{DBI::SQL("NULL")}]\cr Value to replace
\code{NA} values with. If \code{NULL} missing values are propagated, that is an \code{NA}
result will cause \code{NA} output. Otherwise the value is replaced by the
value of \code{.na}.}
    \item{\code{.x}}{[\code{listish}]\cr An environment, list, or data frame used to lookup values.}
    \item{\code{.open}}{[\code{character(1)}: \sQuote{\\{}]\cr The opening delimiter. Doubling the
full delimiter escapes it.}
    \item{\code{.close}}{[\code{character(1)}: \sQuote{\\}}]\cr The closing delimiter. Doubling the
full delimiter escapes it.}
    \item{\code{.null}}{[\code{character(1)}: \sQuote{character()}]\cr Value to replace
NULL values with. If \code{character()} whole output is \code{character()}. If
\code{NULL} all NULL values are dropped (as in \code{paste0()}). Otherwise the
value is replaced by the value of \code{.null}.}
    \item{\code{.comment}}{[\code{character(1)}: \sQuote{#}]\cr Value to use as the comment
character.}
    \item{\code{.literal}}{[\code{boolean(1)}: \sQuote{FALSE}]\cr Whether to treat single or
double quotes, backticks, and comments as regular characters (vs. as
syntactic elements), when parsing the expression string. Setting \code{.literal = TRUE} probably only makes sense in combination with a custom
\code{.transformer}, as is the case with \code{glue_col()}. Regard this argument
(especially, its name) as experimental.}
    \item{\code{.trim}}{[\code{logical(1)}: \sQuote{TRUE}]\cr Whether to trim the input
template with \code{\link[glue:trim]{trim()}} or not.}
  }}

\item{.envir}{environment in which to lookup parametric values not found in
\code{...}. By default, looks at the current calling environment.}

\item{.con}{the SQL connection to use to define the necessary SQL-escaping.
If \code{NULL}, uses the connection defined by calling \code{\link[=start_sql_connection]{start_sql_connection()}}.}
}
\value{
A safe SQL string, with all parametric values properly handled
against SQL injection.
}
\description{
Create a safe SQL expression via parametric string interpolation
}
\details{
Handles all parametric strings, protecting against SQL injection.

By default, parameters in the statement must be given names wrapped in curly
brackets. For example:\preformatted{UPDATE Foo
SET Bar = \{bar\}
}

will replace \code{{bar}} with its associated value (see below). If that
value is a list which should be expanded into a comma-separated list (for
example, within an \code{IN (...)} block), add as asterisk to the name within the
curly brackets (\verb{\{bar*\}}). If the variable defines an SQL identifier (such as
a table name), wrap it in backticks (\code{{`bar`}})

The value associated with each parameter can be defined in a few ways:
\itemize{
\item Have a variable in your calling frame with the same name as the parameter.
\code{write_sql()} will search \code{.envir} (usually the calling frame) for variables
with those names and use them to replace the parameters.
\item Pass a named argument within \code{...} with the same name as the parameter.
This is useful in cases where a few desired values are within a list or
data.frame.
\item Pass a listish object (list, data.frame or environment) to \code{.x} containing
values with the same name as the statement parameter.
}

Parameters will be searched for following the hierarchy below:
\enumerate{
\item if \code{write_sql()} was called with a named argument matching the parameter,
that value is chosen.
\item otherwise, if \code{.x} was defined and contains an element (data.frame column,
list element or environment name) matching the parameter, that value is
chosen.
\item otherwise, if the environment passed to \code{.envir} contains a variable
matching the parameter, that value is chosen. However, if \code{.x} is an
environment, then \code{.envir} is ignored.
\item if no matches are found, an error is thrown.
}

You'll likely never have to define \code{.envir}, unless creating wrappers of your
own, in which case you'll probably want to pass the wrapper's
\code{\link[base:sys.parent]{parent.frame()}}.
}
\note{
Unlike \verb{glue::glue*()} functions used under the hood, \code{write_sql} does not
perform string concatenation.

While the \code{glue} package allows unnamed arguments to be passed to \code{...} and
simply concatenates them to generate the query, \code{write_sql} expects the query
to be fully defined within the \code{sql} argument.

This is done as further protection from SQL injection, to impede the
accidental inclusion of user-input directly into the query string.

Therefore, the function will throw an error if any unnamed arguments are
passed to \code{...}.

If the query must be concatenated by different strings, simply declare them
to be safe SQL via \code{DBI::SQL()}, and then define the \code{sql} argument to
insert those SQL strings as necessary. See Examples below.
}
\examples{
\dontrun{
bar <- 1
write_sql("UPDATE Foo SET Bar = { bar }")
#> <SQL> UPDATE Foo SET Bar = 1

write_sql("UPDATE Foo SET Bar = { bar }",
          bar = 1)
#> <SQL> UPDATE Foo SET Bar = 1

bar <- list(new = 1, old = 2)
write_sql("UPDATE Foo SET Bar = { new } WHERE Bar = { old }",
          .x = bar)
#> <SQL> UPDATE Foo SET Bar = 1 WHERE Bar = 2

bar <- c(1, 2, 3)
write_sql("SELECT * From Foo WHERE Bar IN ({ bar* })")
#> <SQL> SELECT * From Foo WHERE Bar IN (1, 2, 3)

# Properly quotes string parameters to avoid SQL injection
write_sql("SELECT * FROM Foo WHERE Bar = { bar }",
          bar = "buzz; DROP TABLE Foo;")
#> <SQL> SELECT * FROM Foo WHERE Bar = 'Buzz; DROP TABLE Foo;'
}

}
\seealso{
\code{\link[glue:glue_sql]{glue::glue_data_sql()}} and \code{\link[glue:glue]{glue::glue_data()}}, whose arguments
also apply to \code{glue::glue_data_sql()}.
}
\concept{SQL functions}
